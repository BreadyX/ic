#! /usr/bin/env python3
"""interactive c"""
import sys
import os
import argparse
import readline
# import functools
import copy
import shlex
import tempfile

### PROGRAM INFO
NAME = os.path.basename(sys.argv[0])
DESCRIPTION = 'desc'
VERSION = '@version@'

### CMD ARGS
ARG_CMD = 0
ARG_ACTION = 1
ARG_MISC = 2
ARGS_TEMPLATE = ({ARG_CMD: ('-f', '--file'),
                  ARG_ACTION: 'store',
                  ARG_MISC: {'help': 'Specify a file to save to'}},
                 {ARG_CMD: ('-v', '--version'),
                  ARG_ACTION: 'version',
                  ARG_MISC: {'version': VERSION}})

ARGS = None

### MSGs
WELCOME_MSG = "Welcome! Type {} for information on usage"

### PROMPTS
PROMPT_STD = '>> '
PROMPT_MOD = '*> '
PROMPT_ASK = '?> '

### CONTEXT
FUNCTIONS = 0
FUNC_PROTOTYPE = 0
FUNC_BODY = 2
HEADERS = 1
MACROS = 2
GLOBALS = 3

EMPTY_CONTEXT = {HEADERS: ('<stdio.h>', '<stdlib.h>'),
                 MACROS: (),
                 GLOBALS: (),
                 FUNCTIONS: (['int main(int argc, char **argv)',
                              'return 0;'],)}

### CLASSES
class EditString:
    """(Static) Handle inline string editing"""
    _edit_str = ''

    @classmethod
    def has_edit_str(cls):
        """Return True if has edit string, else false"""
        return bool(cls._edit_str)

    @classmethod
    def set_edit_str(cls, edit_string):
        """Sets the string that will be edited by the user to `edit_string`"""
        def pre_input_hook():
            readline.insert_text(cls._edit_str)
            readline.redisplay()

        cls._edit_str = edit_string
        readline.set_pre_input_hook(pre_input_hook)

    @classmethod
    def clear_edit_str(cls):
        """Clear the edit string"""
        cls.set_edit_str('')
        cls._edit_str = ''

class Session:
    """Handle executing commands and keep an instance of the current context"""
    help_cmd = '#?'

    def __init__(self, context, file=None):
        """Create a new Cmd with given context"""
        self.context = copy.deepcopy(context)  # Init context
        # Init working file (None = tmp)
        if file:
            self.file = file
        else:
            self._tmp = True
            handle, self.file = tempfile.mkstemp(text=True)
            os.close(handle)
        # Init function editing stack
        self._stack = list()
        self._stack.append(self.context[FUNCTIONS][0][FUNC_PROTOTYPE])
        self.current_func = self._stack[-1]

    def close(self):
        """Close current session"""
        self._stack.clear()
        self.context = None
        if self._tmp:
            os.remove(self.file)

    @classmethod
    def close_all(cls):
        """"Close all sessions opened"""
        for session in cls.active_sessions:
            session.close()

    def default(self, user_input):
        """Handle command not recognized'"""
        print("???")

    def do_hi(self, _):
        print("Hi")

#    def do_define(self, *args):
#        """Handle #define command"""
#        pass
#
#    def do_[action](self, *args):
#        pass

### FUNCTIONS
def prompt(prompt_str):
    """
    Draws prompt and returns the user input. If EOF is encountered, return
    None
    """
    try:
        return input(prompt_str)
    except EOFError:
        return None

def setup_args(argv):
    """Setup args"""
    parser = argparse.ArgumentParser(prog=NAME, description=DESCRIPTION)
    for arg in ARGS_TEMPLATE:
        parser.add_argument(*arg[ARG_CMD], action=arg[ARG_ACTION], **arg[ARG_MISC])
    return parser.parse_args(args=argv)

def create_session(sessions, *args):
    sessions.append(Session(args))
    return sessions[-1]

def close_session(sessions, session):
    session.close()
    sessions.remove(session)

def main(argv):
    """Main function"""
    cmd_args = setup_args(argv)
    loop = True
    sessions = []

    try:
        session = create_session(sessions, EMPTY_CONTEXT, cmd_args.file)
        while loop:
            user_input = prompt(f'{session.current_func} {PROMPT_STD}')
            if not user_input:  # check for empty input
                print()  # alignment
                continue
            if user_input[0] == '#':
                user_input = user_input[1:]  # strip '#'
                split_input = shlex.split(user_input)
                if split_input[0] == 'new':
                    session = create_session(sessions, EMPTY_CONTEXT, None)
                elif split_input[0] == 'close':
                    # close current session and pop it
                    close_session(sessions, session)
                    if sessions:
                        session = sessions[-1]
                    else:
                        loop = False
                else:
                    try:
                        handler = getattr(Session, f'do_{split_input[0]}')
                        handler(session, split_input[1:])
                    except AttributeError:
                        session.default(split_input)
            else:
                pass
    except KeyboardInterrupt:
        for to_close in sessions:
            to_close.close()
            print()

if __name__ == '__main__':
    main(sys.argv[1:])
