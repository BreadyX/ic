#! /usr/bin/env python3
""" Interactive C """

import sys
import os
import argparse
import tempfile
import readline
import functools

NAME = "@name@"
VERSION = "@version@"
DEFAULT_COMPILER = '@default_compiler@'

DESCRIPTION = 'A shell-like environment for quickly writing simple C programs.'
EPILOG = f'Default compiler: {DEFAULT_COMPILER}.'

VERSION_DIALOG = ("{} version {}\n"
                  "Written by BreadyX, contacts:\n"
                  "\tGitHub repo (BXU):  https://github.com/BreadyX/bxu")

PROMPT_STD = '>> '
PROMPT_CON = '\> '

COMPILER = 0
CURRENT_FUNC = 1
HEADERS = 2
MACROS = 3
GLOBALS = 4
FUNCTIONS = 5

MAIN_PROTOTYPE = "int main(int argc, char **argv)"

class ProgramExit(Exception):
    """Exception that signals a #quit command"""

def main():
    """Main function"""
    argv = handle_argv()
    comp = argv.compiler
    if argv.version:
        print(VERSION_DIALOG.format(NAME, VERSION))
        sys.exit(0)
    workspace = init_workspace(comp)
    main_loop(workspace)

def handle_argv():
    """Set up ArgumentParser and return the namespace obtained after parsing"""
    parser = argparse.ArgumentParser(prog=NAME, description=DESCRIPTION,
                                     epilog=EPILOG)

    parser.add_argument('-c', '--compiler', action='store',
                        help='Use this compiler')
    parser.add_argument('-v', '--version', action='store_true',
                        help='Info about version')

    return parser.parse_args()

def init_workspace(compiler):
    """Creates a dict (workspace) with all the info necessary"""
    if not compiler:
        compiler = DEFAULT_COMPILER
    return {COMPILER: compiler,
            CURRENT_FUNC: 0,
            HEADERS: ['<stdio.h>', '<stdlib.h>'],
            MACROS: [],
            GLOBALS: [],
            FUNCTIONS: [['int main(int argc, char **argv)', [],],]}

def main_loop(workspace):
    """Main prompt loop"""
    print("Welcome! Type '#help' for information")
    while True:
        user_input = prompt(f'{get_current_function(workspace)} {PROMPT_STD}')
        if user_input is None:
            print()
            break
        if user_input:
            if user_input[0] == '#':
                command, args = parse_command(user_input)
                if command is None:
                    print("Invalid command! Type '#help' for more information")
                else:
                    try:
                        command(workspace, args)
                    except ProgramExit:
                        break
            else:
                add_to_current_func(workspace, user_input)
    print("Goodbye!")

def get_current_function(workspace):
    """Extract current function protoype from workspace"""
    func_i = workspace[CURRENT_FUNC]
    return workspace[FUNCTIONS][func_i][0]

def prompt(prompt_str):
    """Draws prompt and returns user input. If EOF, return None"""
    try:
        return input(prompt_str)
    except EOFError:
        return None

def add_to_current_func(workspace, user_input):
    """Adds to current working func user_input"""
    func_i = workspace[CURRENT_FUNC]
    workspace[FUNCTIONS][func_i][1].append(user_input)

def parse_command(user_input):
    """Parse user_input and return corresponding handle function"""
    function_table = {'include': include_command,
                      'define': define_command,
                      'global': global_command,
                      'begin': begin_command,
                      'end': end_command,
                      'see': see_command,
                      'rm': rm_command,
                      'run': None,
                      'clear': None,
                      'help': None,  # added later with partial
                      'quit': quit_command,}
    function_table['help'] = functools.partial(help_command, function_table)
    if not user_input[0] == '#':
        return None, None
    split_str = user_input.split(sep=' ')
    return (function_table.get(split_str[0][1:]), split_str[1:])

### COMMAND FUNCTIONS ###
def include_command(workspace, args):
    if not args:
        print("Invalid call to #include: at least one argument necessary")
    elif "-h" in args:
        print("#include <header>|\"header\" [-h]: include specified header")
    else:
        workspace[HEADERS].append(args[0])

def define_command(workspace, args):
    if not args:
        print("Invalid call to #define: at least one argument necessary")
    elif "-h" in args:
        print("#define macro [-h]: define macro. Can be multiline by having \\"
              " as the last char in line")
        return
    macro_name = args[0]
    macro_content = ' '.join(args[1:])
    lines = [macro_content.strip('\\').strip()]
    old_macro = find_macro_with_name(workspace, macro_name)
    if not old_macro:
        workspace[MACROS].append([macro_name, ''])
        old_macro = workspace[MACROS][len(workspace[MACROS]) - 1]  # get last macro
    while macro_content[-1] == '\\':
        macro_content = prompt(PROMPT_CON)
        lines.append(macro_content.strip('\\').strip())
    old_macro[1] = lines

def find_macro_with_name(workspace, macro_name):
    """Find macro data that has name macro_name"""
    for m in workspace[MACROS]:
        if m[0] == macro_name:
            return m
    return None

def global_command(workspace, args):
    """Function that handles the #global command"""
    if not args:
        print("Invalid call to #global command")
    elif args[0] == '-h':
        print("#global statement [-h]: add statement to the list of global "
              "statements.")
    else:
        statement = ' '.join(args)
        if not statement in workspace[GLOBALS]:
            workspace[GLOBALS].append(statement)

def begin_command(workspace, args):
    """Function that handles #begin command"""
    if not args:
        print("Invalid call to #begin command")
    elif "-h" in args:
        print("#begin func_prototype [-h]: start adding to function with protoype"
              "func_prototype")
    else:
        prototype = ' '.join(args)
        for i, item in enumerate(workspace[FUNCTIONS]):
            if prototype == item[0]:
                workspace[CURRENT_FUNC] = i
                return
        workspace[FUNCTIONS].append([prototype, [],])
        workspace[CURRENT_FUNC] = len(workspace[FUNCTIONS]) - 1

def end_command(workspace, args):
    """Function that handles #end command"""
    if args and args[0] == '-h':
        print("#end [-h]: End adding to current function and return to adding "
              "to main")
    else:
        workspace[CURRENT_FUNC] = 0  # 0 will always be main

def see_command(workspace, args):
    """Function that handles the #see command"""
    if not args:
        args.append("-a")
    if "-h" in args:
        print("#see [-a] [-g] [-H] [-m macro] [-h] [-f func]: Print the contents of specified"
              " object. If nothing is specified, print all.\n"
              "\t-a       print all\n"
              "\t-H       print all headers\n"
              "\t-m macro print macros with name macro. If non specified print "
              " all\n"
              "\t-g       print all globals\n"
              "\t-f func  print function with prototype func. If none specified"
              " print all")
        return
    i = 0
    while i < len(args):
        arg = args[i]
        if arg == "-a":
            print_headers(workspace)
            print_macro(workspace, None)
            print_globals(workspace)
            print_function(workspace, None)
            break;
        elif arg == "-H":
            print_headers(workspace)
        elif arg == "-m":
            if len(args) > i + 1 and args[i + 1][0] != '-':
                print_macro(workspace, args[i + 1])
                i += 1
            else:
                print_macro(workspace, None)
        elif arg == "-g":
            print_globals(workspace)
        elif arg == "-f":
            j, prototype = get_prototype_from_argv(args[i + 1:])
            print_function(workspace, prototype)
            i = i + 1 + j;
        else:
            print(f'Invalid call to #see: option {arg} not valid')
            break
        i += 1

def print_headers(workspace):
    """Print all headers inside workspace"""
    for i, header in enumerate(workspace[HEADERS]):
        print(f'#include {header}')

def print_macro(workspace, macro_name):
    """Print all macros inside workspace"""
    if not macro_name:
        for m in workspace[MACROS]:
            print_macro_data(m)
    else:
        macro_data = find_macro_with_name(workspace, macro_name)
        if macro_data:
            print_macro_data(macro_data)
        else:
            print(f'Macro with name {macro_name} doesn\'t exist')

def print_macro_data(macro_data):
    """Print and format macro data in macro_data"""
    print(f'#define {macro_data[0]} ', end='')
    for i, line in enumerate(macro_data[1]):
        print(f'\t{line}', end='')
        if macro_data[1][i + 1:]:
            print(" \\ ", end='')
        print('\n', end='')

def print_globals(workspace):
    """Print all globals inside workspace"""
    for i, glob in enumerate(workspace[GLOBALS]):
        print(f'{glob}')

def get_prototype_from_argv(prototype_loc):
    """Extract prototype from args slice"""
    j = 0
    prototype = ''
    for j, f_arg in enumerate(prototype_loc):
        if f_arg[0] == '-':
            j -= 1;
            break;
        else:
            prototype += f_arg + ' '
    return j, prototype.strip()

def print_function(workspace, prototype):
    """Print function with prototype 'prototype'. If prototype is empty or None,
    print all functions"""
    if not prototype:
        for func in workspace[FUNCTIONS]:
            print_function_data(func)
    else:
        function_data = find_func_with_prototype(workspace, prototype)
        if function_data:
            print_function_data(function_data)
        else:
            print(f'Function with prototype {prototype} doesn\'t exist')

def print_function_data(function):
    """Print and format function data in function"""
    print(function[0] + " {")
    for line in function[1]:
        print("\t" + line)
    print("}")

def find_func_with_prototype(workspace, prototype):
    """Find function data that contains prototype"""
    for func in workspace[FUNCTIONS]:
        if func[0] == prototype:
            return func
    return None

def rm_command(workspace, args):
    """Function that handles the #rm command"""
    if not args:
        print("Invalid call to #rm command")
        return
    elif "-h" in args:
        print("#rm -H|-g|-m|-f exp [-h]: removes argument from workspace.\n"
              "\t-H header     remove header from workspace\n"
              "\t-g global     remove global from workspace\n"
              "\t-m macro      remove macro from workspace\n"
              "\t-f prototype  remove header from workspace\n")
        return
    exp = ' '.join(args[1:])
    # Who decided switches are too stupid for python?
    if args[0] == '-H':
        try:
            workspace[HEADERS].remove(exp)
        except ValueError:
            print(f'Invalid call to #rm: header {exp} doesn\'t exist')
    elif args[0] == '-g':
        try:
            workspace[GLOBALS].remove(exp)
        except ValueError:
            print(f'Invalid call to #rm: global {exp} doesn\'t exist')
    elif args[0] == '-m':
        macro = find_macro_with_name(workspace, exp)
        if macro:
            workspace[MACROS].remove(macro)
        else:
            print(f'Invalid call to #rm: macro {exp} doesn\'t exist')
    elif args[0] == '-f':
        function = find_func_with_prototype(workspace, exp)
        if function:
            if function[0] == MAIN_PROTOTYPE:
                print("Blocking attempt to remove main function. Please use #clear")
                return
            workspace[FUNCTIONS].remove(function)
        else:
            print(f'Invalid call to #rm: function {exp} doesn\'t exist')

def help_command(function_table, workspace, args):
    """Print help dialog for each command (#help command)"""
    if not args:
        print("#help [command]: print help for all commands or the one specified\n")
        for _, item in function_table.items():
            if item and item != function_table['help']:
                item(workspace, ["-h"])
                print()
    else:
        requested = function_table.get(args[0])
        if requested and requested != function_table['help']:
            requested(workspace, ['-h'])
        elif requested == function_table['help']:
            return
        else:
            print(f'Invalid call to #help: command {args[0]} not found')

def quit_command(_, args):
    """Quit @name@ (#quit command)"""
    if args and args[0] == '-h':
        print(f'#quit [-h]: quit {NAME}')
    else:
        raise ProgramExit()

### MAIN IF ###
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Goodbye")
